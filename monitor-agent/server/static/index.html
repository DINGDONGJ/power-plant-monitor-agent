<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>电厂核心软件监视保障系统</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background: #0a0a0a; 
            color: #00ff00; 
            font-size: 14px;
            line-height: 1.4;
        }
        .container { max-width: 1800px; margin: 0 auto; padding: 10px; }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            margin-bottom: 10px;
        }
        .header h1 { color: #ffffff; font-size: 16px; font-weight: bold; }
        .header .time { color: #888; }
        
        .system-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }
        .resource-box {
            background: #0d0d0d;
            border: 1px solid #333;
            padding: 10px;
        }
        .resource-box .title { 
            color: #00ffff; 
            font-weight: bold; 
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .resource-box .current-value { color: #00ff00; font-size: 14px; }
        .chart-container {
            position: relative;
            height: 100px;
            background: #111;
            border: 1px solid #333;
        }
        .chart-container canvas {
            width: 100%;
            height: 100%;
        }
        .resource-info { display: flex; justify-content: space-between; color: #888; font-size: 12px; margin-top: 5px; }
        
        .tabs { display: flex; background: #1a1a1a; border: 1px solid #333; border-bottom: none; }
        .tab {
            padding: 8px 20px; background: transparent; border: none;
            color: #888; cursor: pointer; font-family: inherit; font-size: 14px;
        }
        .tab:hover { color: #00ff00; }
        .tab.active { background: #0d0d0d; color: #00ff00; border-bottom: 2px solid #00ff00; }
        
        .panel { display: none; background: #0d0d0d; border: 1px solid #333; padding: 10px; min-height: 400px; }
        .panel.active { display: block; }
        
        .toolbar { display: flex; gap: 10px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #333; align-items: center; flex-wrap: wrap; }
        .btn { padding: 5px 15px; background: #1a1a1a; border: 1px solid #444; color: #00ff00; cursor: pointer; font-family: inherit; font-size: 12px; }
        .btn:hover { background: #2a2a2a; border-color: #00ff00; }
        .btn.danger { color: #ff4444; }
        .btn.danger:hover { border-color: #ff4444; }
        input[type="text"] { padding: 5px 10px; background: #1a1a1a; border: 1px solid #444; color: #00ff00; font-family: inherit; font-size: 12px; width: 200px; }
        input[type="text"]:focus { outline: none; border-color: #00ff00; }
        
        .table-container { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; min-width: 1200px; }
        th, td { padding: 6px 8px; text-align: left; border-bottom: 1px solid #222; white-space: nowrap; }
        th { color: #00ffff; cursor: pointer; user-select: none; background: #111; position: relative; }
        th:hover { color: #fff; }
        th .sort-indicator { color: #ffff00; }
        th.dragging { opacity: 0.5; background: #333; }
        th.drag-over { border-left: 2px solid #00ff00; }
        tr:hover { background: #1a1a1a; }
        tr.monitored { background: #0a2a0a; color: #00ff00; }
        tr.monitored:hover { background: #0a3a0a; }
        tr.group-header { cursor: pointer; }
        tr.group-header:hover { background: #1a2a1a; }
        tr.group-child { background: #0a0a0a; }
        tr.group-child:hover { background: #151515; }
        tr.group-child.monitored { background: #0a2a0a; }
        .checkbox { cursor: pointer; }
        .cmdline { max-width: 200px; overflow: hidden; text-overflow: ellipsis; }
        
        .status { font-size: 12px; }
        .status-running { color: #00ff00; }
        .status-stopped { color: #ff4444; }
        
        .monitor-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #333; }
        .monitor-status { color: #888; }
        .monitor-status.running { color: #00ff00; }
        .monitor-status.running::before { content: '● '; }
        .monitor-status.stopped { color: #ff4444; }
        .monitor-status.stopped::before { content: '○ '; }
        
        .targets-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 10px; }
        .target-card { background: #111; border: 1px solid #333; padding: 12px; }
        .target-card .name { color: #00ffff; font-weight: bold; margin-bottom: 10px; }
        .target-card .row { display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px dotted #222; }
        .target-card .label { color: #888; }
        .target-card .value { color: #00ff00; }
        .target-card .value.dead { color: #ff4444; }
        .target-card .btn { margin-top: 10px; width: 100%; }
        
        .event-list { max-height: 500px; overflow-y: auto; }
        .event-item { padding: 8px; border-bottom: 1px solid #222; font-size: 13px; }
        .event-item .time { color: #666; margin-right: 10px; }
        .event-item .type { font-weight: bold; margin-right: 10px; }
        .event-item .type-exit { color: #ff4444; }
        .event-item .type-restart { color: #ffaa00; }
        .event-item .type-cpu_threshold { color: #ff00ff; }
        
        .stats { color: #888; font-size: 12px; }
        .drag-handle { cursor: grab; color: #666; margin-right: 5px; }
        .drag-handle:active { cursor: grabbing; }
        
        /* 右键菜单样式 */
        .context-menu {
            display: none;
            position: fixed;
            background: #1a1a1a;
            border: 1px solid #444;
            min-width: 150px;
            z-index: 1000;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.5);
        }
        .context-menu.show { display: block; }
        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ccc;
            font-size: 13px;
        }
        .context-menu-item:hover { background: #2a2a2a; color: #00ff00; }
        .context-menu-item .check { color: #00ff00; width: 16px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>[ 电厂核心软件监视保障系统 v1.0 ]</h1>
            <span class="time" id="currentTime"></span>
        </div>
        
        <div class="system-panel">
            <div class="resource-box">
                <div class="title">
                    <span>处理器 (CPU)</span>
                    <span class="current-value" id="cpuValue">0%</span>
                </div>
                <div class="chart-container">
                    <canvas id="cpuChart"></canvas>
                </div>
                <div class="resource-info"><span>60秒历史</span><span id="cpuInfo">-</span></div>
            </div>
            <div class="resource-box">
                <div class="title">
                    <span>内存 (RAM)</span>
                    <span class="current-value" id="memValue">0%</span>
                </div>
                <div class="chart-container">
                    <canvas id="memChart"></canvas>
                </div>
                <div class="resource-info"><span>60秒历史</span><span id="memInfo">-</span></div>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showPanel('processes')">进程列表</button>
            <button class="tab" onclick="showPanel('monitor')">监控面板</button>
            <button class="tab" onclick="showPanel('events')">事件日志</button>
        </div>

        <div id="processes" class="panel active">
            <div class="toolbar">
                <input type="text" id="searchInput" placeholder="搜索进程..." oninput="filterProcesses()">
                <button class="btn" onclick="addSelectedToMonitor()">+ 添加到监控</button>
                <span class="stats">已选: <span id="selectedCount">0</span> | 总计: <span id="totalCount">0</span></span>
                <span class="stats" style="margin-left:auto">拖动表头调整列顺序</span>
            </div>
            <div class="table-container">
                <table>
                    <thead><tr id="tableHeader"></tr></thead>
                    <tbody id="processTable"></tbody>
                </table>
            </div>
        </div>

        <div id="monitor" class="panel">
            <div class="monitor-header">
                <span class="monitor-status stopped" id="monitorStatus">已停止</span>
                <div>
                    <button class="btn" id="startBtn" onclick="startMonitor()">▶ 启动</button>
                    <button class="btn danger" id="stopBtn" onclick="stopMonitor()" style="display:none">■ 停止</button>
                </div>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
                <h4 style="color:#00ffff;font-weight:normal">监控目标</h4>
                <button class="btn danger" onclick="removeAllTargets()">全部移除</button>
            </div>
            <div class="targets-grid" id="targetsList"></div>
        </div>

        <div id="events" class="panel">
            <div class="event-list" id="eventList"></div>
        </div>
        
        <!-- 列显示/隐藏右键菜单 -->
        <div class="context-menu" id="columnMenu"></div>
    </div>

    <script>
        let allProcesses = [];
        let selectedPids = new Set();
        let monitoredPids = new Set();
        let refreshInterval = null;
        let processRefreshInterval = null;
        let eventsRefreshInterval = null;
        let systemRefreshInterval = null;
        let sortColumn = 'cpu';
        let sortAsc = false;
        let expandedGroups = new Set();
        
        // 时间序列数据（保存60个数据点，每2秒一个）
        const MAX_DATA_POINTS = 60;
        let cpuHistory = [];
        let memHistory = [];
        let lastMemInfo = { used: 0, total: 0 };

        // 列定义：key, 标题, 宽度, 是否可排序
        const allColumns = [
            { key: 'checkbox', title: '<input type="checkbox" class="checkbox" id="selectAll" onchange="toggleSelectAll()">', width: '30px', sortable: false },
            { key: 'name', title: '进程名称', width: 'auto', sortable: true },
            { key: 'pid', title: 'PID', width: '70px', sortable: true },
            { key: 'status', title: '状态', width: '60px', sortable: true },
            { key: 'username', title: '发布者', width: '100px', sortable: true },
            { key: 'cpu', title: 'CPU%', width: '80px', sortable: true },
            { key: 'mem', title: '内存', width: '90px', sortable: true },
            { key: 'disk', title: '磁盘', width: '90px', sortable: true },
            { key: 'cmdline', title: '命令行', width: '200px', sortable: false }
        ];

        // 当前列顺序（从 localStorage 加载或使用默认）
        let columnOrder = JSON.parse(localStorage.getItem('columnOrder')) || allColumns.map(c => c.key);
        
        // 列可见性（从 localStorage 加载或默认全部显示）
        let columnVisibility = JSON.parse(localStorage.getItem('columnVisibility')) || {};
        // 默认全部可见
        allColumns.forEach(c => {
            if (columnVisibility[c.key] === undefined) columnVisibility[c.key] = true;
        });
        // checkbox 列始终显示
        columnVisibility['checkbox'] = true;
        
        // 确保所有列都在
        allColumns.forEach(c => {
            if (!columnOrder.includes(c.key)) columnOrder.push(c.key);
        });
        columnOrder = columnOrder.filter(k => allColumns.find(c => c.key === k));

        function saveColumnOrder() {
            localStorage.setItem('columnOrder', JSON.stringify(columnOrder));
        }
        
        function saveColumnVisibility() {
            localStorage.setItem('columnVisibility', JSON.stringify(columnVisibility));
        }
        
        function getVisibleColumns() {
            return columnOrder.filter(key => columnVisibility[key]);
        }

        function getColumnByKey(key) {
            return allColumns.find(c => c.key === key);
        }

        // 渲染表头
        function renderTableHeader() {
            const tr = document.getElementById('tableHeader');
            const visibleCols = getVisibleColumns();
            tr.innerHTML = visibleCols.map(key => {
                const col = getColumnByKey(key);
                if (!col) return '';
                const sortIndicator = col.sortable && sortColumn === key ? (sortAsc ? ' ▲' : ' ▼') : '';
                const draggable = key !== 'checkbox' ? 'draggable="true"' : '';
                const onclick = col.sortable ? `onclick="sortProcesses('${key}')"` : '';
                const style = col.width !== 'auto' ? `style="width:${col.width}"` : '';
                return `<th data-key="${key}" ${draggable} ${onclick} ${style}>${col.title}<span class="sort-indicator">${sortIndicator}</span></th>`;
            }).join('');
            
            // 添加拖放事件和右键菜单
            tr.querySelectorAll('th').forEach(th => {
                if (th.getAttribute('draggable') === 'true') {
                    th.addEventListener('dragstart', handleDragStart);
                    th.addEventListener('dragover', handleDragOver);
                    th.addEventListener('dragleave', handleDragLeave);
                    th.addEventListener('drop', handleDrop);
                    th.addEventListener('dragend', handleDragEnd);
                }
                th.addEventListener('contextmenu', showColumnMenu);
            });
        }
        
        // 显示列选择菜单
        function showColumnMenu(e) {
            e.preventDefault();
            const menu = document.getElementById('columnMenu');
            // 生成菜单项（排除 checkbox）
            menu.innerHTML = allColumns.filter(c => c.key !== 'checkbox').map(col => {
                const visible = columnVisibility[col.key];
                const checkMark = visible ? '✓' : '';
                return `<div class="context-menu-item" onclick="toggleColumnVisibility('${col.key}')">
                    <span class="check">${checkMark}</span>
                    <span>${col.title}</span>
                </div>`;
            }).join('');
            
            // 定位菜单
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
            menu.classList.add('show');
            
            // 点击其他地方关闭菜单
            setTimeout(() => {
                document.addEventListener('click', hideColumnMenu, { once: true });
            }, 0);
        }
        
        function hideColumnMenu() {
            document.getElementById('columnMenu').classList.remove('show');
        }
        
        function toggleColumnVisibility(key) {
            columnVisibility[key] = !columnVisibility[key];
            saveColumnVisibility();
            renderTableHeader();
            renderProcesses(getFilteredProcesses());
        }

        let draggedColumn = null;

        function handleDragStart(e) {
            draggedColumn = e.target.dataset.key;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.target.closest('th').classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.target.closest('th').classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetKey = e.target.closest('th').dataset.key;
            if (draggedColumn && targetKey && draggedColumn !== targetKey && targetKey !== 'checkbox') {
                const fromIdx = columnOrder.indexOf(draggedColumn);
                const toIdx = columnOrder.indexOf(targetKey);
                columnOrder.splice(fromIdx, 1);
                columnOrder.splice(toIdx, 0, draggedColumn);
                saveColumnOrder();
                renderTableHeader();
                renderProcesses(getFilteredProcesses());
            }
            e.target.closest('th').classList.remove('drag-over');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('th').forEach(th => th.classList.remove('drag-over'));
        }


        function updateTime() {
            document.getElementById('currentTime').textContent = new Date().toLocaleString('zh-CN');
        }
        setInterval(updateTime, 1000);
        updateTime();

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / 1024 / 1024).toFixed(1) + ' MB';
            return (bytes / 1024 / 1024 / 1024).toFixed(2) + ' GB';
        }

        function getLevel(percent) {
            if (percent < 50) return 'level-low';
            if (percent < 70) return 'level-mid';
            if (percent < 90) return 'level-high';
            return 'level-critical';
        }

        async function refreshSystem() {
            try {
                const res = await fetch('/api/system');
                const data = await res.json();
                
                // 更新时间序列数据
                cpuHistory.push(data.cpu_percent);
                memHistory.push(data.memory_percent);
                if (cpuHistory.length > MAX_DATA_POINTS) cpuHistory.shift();
                if (memHistory.length > MAX_DATA_POINTS) memHistory.shift();
                
                // 更新当前值显示
                document.getElementById('cpuValue').textContent = data.cpu_percent.toFixed(2) + '%';
                document.getElementById('memValue').textContent = data.memory_percent.toFixed(2) + '%';
                document.getElementById('cpuInfo').textContent = '当前: ' + data.cpu_percent.toFixed(2) + '%';
                document.getElementById('memInfo').textContent = formatBytes(data.memory_used) + ' / ' + formatBytes(data.memory_total);
                lastMemInfo = { used: data.memory_used, total: data.memory_total };
                
                // 绘制图表
                drawChart('cpuChart', cpuHistory, '#00ff00', '#003300');
                drawChart('memChart', memHistory, '#00ffff', '#003333');
            } catch (e) {
                console.error('获取系统指标失败:', e);
            }
        }
        
        function drawChart(canvasId, data, lineColor, fillColor) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const rect = canvas.parentElement.getBoundingClientRect();
            
            // 设置 canvas 实际尺寸
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            const width = canvas.width;
            const height = canvas.height;
            const padding = { top: 5, right: 10, bottom: 5, left: 30 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // 清空画布
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            
            // 绘制网格线和Y轴标签
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#555';
            ctx.font = '10px Consolas';
            ctx.textAlign = 'right';
            
            // 水平网格线
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight * i / 4);
                const value = 100 - (i * 25);
                
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
                
                ctx.fillText(value + '%', padding.left - 3, y + 3);
            }
            
            // 垂直网格线（每10个数据点一条）
            for (let i = 0; i <= MAX_DATA_POINTS; i += 10) {
                const x = padding.left + (i / MAX_DATA_POINTS) * chartWidth;
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, padding.top + chartHeight);
                ctx.stroke();
            }
            
            if (data.length < 1) return;
            
            // Steam 风格：数据从右向左滚动，最新数据在最右边
            // 计算点的位置，数据不足时从右边开始绘制
            const startX = padding.left + chartWidth - ((data.length - 1) / (MAX_DATA_POINTS - 1)) * chartWidth;
            const stepX = chartWidth / (MAX_DATA_POINTS - 1);
            
            const points = data.map((val, idx) => ({
                x: startX + idx * stepX,
                y: padding.top + chartHeight - (val / 100) * chartHeight
            }));
            
            // 创建渐变填充
            const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartHeight);
            gradient.addColorStop(0, fillColor);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            // 绘制填充区域
            ctx.beginPath();
            ctx.moveTo(points[0].x, padding.top + chartHeight);
            points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.lineTo(points[points.length - 1].x, padding.top + chartHeight);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // 绘制折线（带发光效果）
            ctx.shadowColor = lineColor;
            ctx.shadowBlur = 4;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // 绘制最新值的点（最右边）
            if (points.length > 0) {
                const lastPoint = points[points.length - 1];
                ctx.beginPath();
                ctx.arc(lastPoint.x, lastPoint.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = lineColor;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        function showPanel(name) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.getElementById(name).classList.add('active');
            event.target.classList.add('active');
            
            stopAllIntervals();
            startSystemRefresh();
            
            if (name === 'processes') {
                startProcessAutoRefresh();
            } else if (name === 'monitor') {
                refreshTargets();
                startAutoRefresh();
            } else if (name === 'events') {
                refreshEvents();
                startEventsAutoRefresh();
            }
        }

        function stopAllIntervals() {
            if (refreshInterval) { clearInterval(refreshInterval); refreshInterval = null; }
            if (processRefreshInterval) { clearInterval(processRefreshInterval); processRefreshInterval = null; }
            if (eventsRefreshInterval) { clearInterval(eventsRefreshInterval); eventsRefreshInterval = null; }
        }

        function startSystemRefresh() {
            if (systemRefreshInterval) return;
            refreshSystem();
            systemRefreshInterval = setInterval(refreshSystem, 2000);
        }

        function sortProcesses(column) {
            if (sortColumn === column) {
                sortAsc = !sortAsc;
            } else {
                sortColumn = column;
                sortAsc = false;
            }
            renderTableHeader();
            renderProcesses(getFilteredProcesses());
        }

        function getFilteredProcesses() {
            const keyword = document.getElementById('searchInput').value.toLowerCase();
            let filtered = allProcesses;
            if (keyword) {
                filtered = allProcesses.filter(p => 
                    (p.name && p.name.toLowerCase().includes(keyword)) || 
                    String(p.pid).includes(keyword) ||
                    (p.username && p.username.toLowerCase().includes(keyword)) ||
                    (p.cmdline && p.cmdline.toLowerCase().includes(keyword))
                );
            }
            return filtered;
        }

        async function refreshProcesses() {
            try {
                const [procRes, targetsRes] = await Promise.all([
                    fetch('/api/processes'),
                    fetch('/api/monitor/targets')
                ]);
                allProcesses = await procRes.json();
                const targets = await targetsRes.json();
                monitoredPids = new Set(targets.map(t => t.pid));
                document.getElementById('totalCount').textContent = allProcesses.length;
                renderProcesses(getFilteredProcesses());
            } catch (e) {
                console.error('获取进程列表失败:', e);
            }
        }

        function startProcessAutoRefresh() {
            if (processRefreshInterval) return;
            refreshProcesses();
            processRefreshInterval = setInterval(refreshProcesses, 2000);
        }

        function toggleGroup(name) {
            if (expandedGroups.has(name)) expandedGroups.delete(name);
            else expandedGroups.add(name);
            renderProcesses(getFilteredProcesses());
        }

        // 格式化磁盘速率
        function formatDiskRate(bytesPerSec) {
            if (bytesPerSec < 1024) return bytesPerSec.toFixed(0) + ' B/s';
            if (bytesPerSec < 1024 * 1024) return (bytesPerSec / 1024).toFixed(1) + ' KB/s';
            return (bytesPerSec / 1024 / 1024).toFixed(1) + ' MB/s';
        }

        function getCellValue(p, key, isGroup = false, group = null) {
            if (isGroup) {
                switch (key) {
                    case 'checkbox':
                        const groupSelected = group.procs.every(pr => selectedPids.has(pr.pid));
                        const groupPartial = group.procs.some(pr => selectedPids.has(pr.pid)) && !groupSelected;
                        return `<input type="checkbox" class="checkbox" ${groupSelected ? 'checked' : ''} ${groupPartial ? 'style="opacity:0.5"' : ''} onclick="event.stopPropagation();toggleGroupSelect('${group.name.replace(/'/g, "\\'")}')">`;
                    case 'name':
                        const isExpanded = expandedGroups.has(group.name);
                        return `${group.hasMonitored ? '● ' : ''}${isExpanded ? '▼' : '▶'} ${group.name} <span style="color:#888">(${group.procs.length})</span>`;
                    case 'pid': return '-';
                    case 'status': return group.procs.length;
                    case 'username': return '-';
                    case 'cpu': return group.totalCpu.toFixed(2);
                    case 'mem': return formatBytes(group.totalMem);
                    case 'disk': return formatDiskRate(group.totalDiskIO);
                    case 'cmdline': return '-';
                    default: return '-';
                }
            } else {
                const isMonitored = monitoredPids.has(p.pid);
                switch (key) {
                    case 'checkbox':
                        return `<input type="checkbox" class="checkbox" data-pid="${p.pid}" ${selectedPids.has(p.pid) ? 'checked' : ''} onchange="toggleSelect(${p.pid})">`;
                    case 'name': return `${isMonitored ? '● ' : ''}${p.name || '-'}`;
                    case 'pid': return p.pid;
                    case 'status': return `<span class="status status-running">${p.status || '运行'}</span>`;
                    case 'username': return p.username || '-';
                    case 'cpu': return p.cpu_pct.toFixed(2);
                    case 'mem': return formatBytes(p.rss_bytes);
                    case 'disk': return formatDiskRate(p.disk_io || 0);
                    case 'cmdline': return `<span class="cmdline" title="${(p.cmdline || '').replace(/"/g, '&quot;')}">${p.cmdline || '-'}</span>`;
                    default: return '-';
                }
            }
        }

        function renderProcesses(processes) {
            const tbody = document.getElementById('processTable');
            
            // 按进程名分组
            const groups = {};
            processes.forEach(p => {
                const name = p.name || '-';
                if (!groups[name]) groups[name] = [];
                groups[name].push(p);
            });
            
            // 计算每组的汇总数据
            const groupList = Object.entries(groups).map(([name, procs]) => {
                const totalCpu = procs.reduce((sum, p) => sum + p.cpu_pct, 0);
                const totalMem = procs.reduce((sum, p) => sum + p.rss_bytes, 0);
                const totalDiskIO = procs.reduce((sum, p) => sum + (p.disk_io || 0), 0);
                const hasMonitored = procs.some(p => monitoredPids.has(p.pid));
                return { name, procs, totalCpu, totalMem, totalDiskIO, hasMonitored };
            });
            
            // 排序
            groupList.sort((a, b) => {
                if (a.hasMonitored && !b.hasMonitored) return -1;
                if (!a.hasMonitored && b.hasMonitored) return 1;
                
                let valA, valB;
                switch (sortColumn) {
                    case 'name': valA = a.name.toLowerCase(); valB = b.name.toLowerCase(); break;
                    case 'cpu': valA = a.totalCpu; valB = b.totalCpu; break;
                    case 'mem': valA = a.totalMem; valB = b.totalMem; break;
                    case 'disk': valA = a.totalDiskIO; valB = b.totalDiskIO; break;
                    case 'pid': valA = Math.min(...a.procs.map(p => p.pid)); valB = Math.min(...b.procs.map(p => p.pid)); break;
                    default: valA = a.totalCpu; valB = b.totalCpu;
                }
                if (valA < valB) return sortAsc ? -1 : 1;
                if (valA > valB) return sortAsc ? 1 : -1;
                return 0;
            });
            
            let html = '';
            const visibleCols = getVisibleColumns();
            groupList.forEach(group => {
                const { name, procs, hasMonitored } = group;
                const isExpanded = expandedGroups.has(name);
                const count = procs.length;
                
                if (count === 1) {
                    const p = procs[0];
                    const isMonitored = monitoredPids.has(p.pid);
                    html += `<tr class="${isMonitored ? 'monitored' : ''}">`;
                    visibleCols.forEach(key => {
                        html += `<td>${getCellValue(p, key)}</td>`;
                    });
                    html += `</tr>`;
                } else {
                    html += `<tr class="group-header ${hasMonitored ? 'monitored' : ''}" onclick="toggleGroup('${name.replace(/'/g, "\\'")}')">`;
                    visibleCols.forEach(key => {
                        html += `<td>${getCellValue(null, key, true, group)}</td>`;
                    });
                    html += `</tr>`;
                    
                    if (isExpanded) {
                        const sortedProcs = [...procs].sort((a, b) => {
                            const aMonitored = monitoredPids.has(a.pid);
                            const bMonitored = monitoredPids.has(b.pid);
                            if (aMonitored && !bMonitored) return -1;
                            if (!aMonitored && bMonitored) return 1;
                            
                            let valA, valB;
                            switch (sortColumn) {
                                case 'pid': valA = a.pid; valB = b.pid; break;
                                case 'cpu': valA = a.cpu_pct; valB = b.cpu_pct; break;
                                case 'mem': valA = a.rss_bytes; valB = b.rss_bytes; break;
                                case 'disk': valA = a.disk_io || 0; valB = b.disk_io || 0; break;
                                default: valA = a.cpu_pct; valB = b.cpu_pct;
                            }
                            if (valA < valB) return sortAsc ? -1 : 1;
                            if (valA > valB) return sortAsc ? 1 : -1;
                            return 0;
                        });
                        sortedProcs.forEach(p => {
                            const isMonitored = monitoredPids.has(p.pid);
                            html += `<tr class="group-child ${isMonitored ? 'monitored' : ''}">`;
                            visibleCols.forEach((key, idx) => {
                                let val = getCellValue(p, key);
                                if (key === 'name') val = `<span style="padding-left:20px">${val}</span>`;
                                html += `<td>${val}</td>`;
                            });
                            html += `</tr>`;
                        });
                    }
                }
            });
            
            tbody.innerHTML = html;
            updateSelectedCount();
        }


        function toggleGroupSelect(name) {
            const group = allProcesses.filter(p => (p.name || '-') === name);
            const allSelected = group.every(p => selectedPids.has(p.pid));
            group.forEach(p => {
                if (allSelected) selectedPids.delete(p.pid);
                else selectedPids.add(p.pid);
            });
            renderProcesses(getFilteredProcesses());
        }

        function filterProcesses() {
            renderProcesses(getFilteredProcesses());
        }

        function toggleSelect(pid) {
            if (selectedPids.has(pid)) selectedPids.delete(pid);
            else selectedPids.add(pid);
            updateSelectedCount();
        }

        function toggleSelectAll() {
            const checked = document.getElementById('selectAll').checked;
            document.querySelectorAll('#processTable .checkbox').forEach(cb => {
                const pid = parseInt(cb.dataset.pid);
                if (pid) {
                    if (checked) selectedPids.add(pid);
                    else selectedPids.delete(pid);
                }
                cb.checked = checked;
            });
            updateSelectedCount();
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = selectedPids.size;
        }

        async function addSelectedToMonitor() {
            if (selectedPids.size === 0) return alert('请先选择要监控的进程');
            for (const pid of selectedPids) {
                const proc = allProcesses.find(p => p.pid === pid);
                await fetch('/api/monitor/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pid, name: proc?.name || '' })
                });
            }
            await fetch('/api/monitor/start', { method: 'POST' });
            selectedPids.clear();
            updateSelectedCount();
            document.querySelectorAll('.tab')[1].click();
        }

        async function refreshTargets() {
            try {
                const [targetsRes, statusRes, metricsRes] = await Promise.all([
                    fetch('/api/monitor/targets'),
                    fetch('/api/status'),
                    fetch('/api/metrics/latest')
                ]);
                const targets = await targetsRes.json();
                const status = await statusRes.json();
                const metrics = await metricsRes.json();
                renderTargets(targets, metrics);
                updateMonitorStatus(status.running);
            } catch (e) {
                console.error('获取监控目标失败:', e);
            }
        }

        function renderTargets(targets, metrics) {
            const container = document.getElementById('targetsList');
            if (!targets || targets.length === 0) {
                container.innerHTML = '<p style="color:#666">暂无监控目标，请从进程列表添加</p>';
                return;
            }
            container.innerHTML = targets.map(t => {
                const m = metrics[t.pid];
                const alive = m?.alive;
                return `
                <div class="target-card">
                    <div class="name">${t.name || '未知'}</div>
                    <div class="row"><span class="label">进程ID</span><span class="value">${t.pid}</span></div>
                    <div class="row"><span class="label">CPU</span><span class="value">${m ? m.cpu_pct.toFixed(2) + '%' : '-'}</span></div>
                    <div class="row"><span class="label">内存</span><span class="value">${m ? formatBytes(m.rss_bytes) : '-'}</span></div>
                    <div class="row"><span class="label">状态</span><span class="value ${alive ? '' : 'dead'}">${alive ? '运行中' : '已退出'}</span></div>
                    <button class="btn danger" onclick="removeTarget(${t.pid})">移除</button>
                </div>
            `}).join('');
        }

        function updateMonitorStatus(running) {
            const el = document.getElementById('monitorStatus');
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            if (running) {
                el.className = 'monitor-status running';
                el.textContent = '运行中';
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-block';
            } else {
                el.className = 'monitor-status stopped';
                el.textContent = '已停止';
                startBtn.style.display = 'inline-block';
                stopBtn.style.display = 'none';
            }
        }

        async function startMonitor() {
            await fetch('/api/monitor/start', { method: 'POST' });
            refreshTargets();
        }

        async function stopMonitor() {
            await fetch('/api/monitor/stop', { method: 'POST' });
            refreshTargets();
        }

        async function removeTarget(pid) {
            await fetch('/api/monitor/remove', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ pid })
            });
            refreshTargets();
        }

        async function removeAllTargets() {
            if (!confirm('确定要移除所有监控目标吗？')) return;
            await fetch('/api/monitor/removeAll', { method: 'POST' });
            refreshTargets();
        }

        function startAutoRefresh() {
            if (refreshInterval) return;
            refreshInterval = setInterval(refreshTargets, 2000);
        }

        async function refreshEvents() {
            try {
                const res = await fetch('/api/events?n=100');
                const events = await res.json();
                renderEvents(events);
            } catch (e) {
                console.error('获取事件失败:', e);
            }
        }

        function startEventsAutoRefresh() {
            if (eventsRefreshInterval) return;
            eventsRefreshInterval = setInterval(refreshEvents, 2000);
        }

        function renderEvents(events) {
            const container = document.getElementById('eventList');
            if (!events || events.length === 0) {
                container.innerHTML = '<p style="color:#666;padding:20px">暂无事件</p>';
                return;
            }
            const typeMap = { exit: '退出', restart: '重启', cpu_threshold: 'CPU超限' };
            container.innerHTML = events.slice().reverse().map(e => `
                <div class="event-item">
                    <span class="time">${new Date(e.timestamp).toLocaleString('zh-CN')}</span>
                    <span class="type type-${e.type}">[${typeMap[e.type] || e.type.toUpperCase()}]</span>
                    <span>进程ID:${e.pid} ${e.message}</span>
                </div>
            `).join('');
        }

        // 初始化
        renderTableHeader();
        startSystemRefresh();
        startProcessAutoRefresh();
    </script>
</body>
</html>
